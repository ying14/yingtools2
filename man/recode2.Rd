% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/yingtools2.R
\name{recode2}
\alias{recode2}
\alias{recode.grep}
\title{Ying's Recode}
\usage{
recode2(
  var,
  recodes,
  else.value = NULL,
  as.factor = NULL,
  regexp = FALSE,
  replace = FALSE,
  multi.hits = FALSE,
  ignore.case = TRUE,
  perl = FALSE,
  useBytes = TRUE
)

recode.grep(...)
}
\arguments{
\item{var}{the vector to be recoded.}

\item{recodes}{typically, a named vector specifying recodes. Note that order matters; first matching recode will apply
(assuming \code{multi.hits=FALSE}). As an additional option, a named list of vectors can also be used, where each vector of
values will be recoded to its corresponding name.}

\item{else.value}{the value to be used if a value is not recoded. Default is the old value.}

\item{as.factor}{whether or not to code as a factor. The levels will ordered based on \code{recodes}. Default is to base it on whether original vector is a factor.}

\item{regexp}{if \code{TRUE}, use regular expressions. Default is \code{FALSE}, which performs exact matching.}

\item{replace}{if \code{TRUE}, replace the hit (using \code{gsub})instead of replacing the entire field. Note that \code{regexp} and \code{multi.hits} should be \code{TRUE}, if not it will be changed. Default is \code{FALSE}.}

\item{multi.hits}{if \code{TRUE}, will evaluate every value for every recode. So values can be recoded more than one time.}

\item{ignore.case}{whether or not to ignore case, passed to regular expression. Default is \code{TRUE}}

\item{perl}{whether to use perl-style regular expressions. Default is \code{FALSE}}

\item{useBytes}{logical. If TRUE the regex matching is done byte-by-byte rather than character-by-character. Avoids weird locale warnings. (see help for \code{grep})}
}
\value{
A vector consisting of the recoded values of \code{var}
}
\description{
Recode a variable
}
\examples{
data(cid)

# Recode if field matches exactly.
recodes1 <- c("Pseudomonas aeruginosa"="P. aeruginosa","Staphylococcus aureus oxacillin resistant"="MRSA")
bsi$org.short.1 <- recode2(bsi$org.short,recodes1)
bsi$org.short.1

# Recode if there is a regular expression pattern match.
recodes2 <- c("Pseud.+aerug"="P. aeruginosa","oxacill.+resist"="MRSA")
bsi$org.short.2 <- recode2(bsi$org.short,recodes2,regexp=TRUE)
bsi$org.short.2

# Instead of recoding, find and replace text.
recodes3 <- c("Pseudomonas"="P.","Staphylococcus"="S.")
bsi$org.short.3 <- recode2(bsi$org.short,recodes3,replace=TRUE,multi.hits=TRUE)
bsi$org.short.3

# Recode via regular expressions to merge groups.
recodes4 <- c("enterococcus|staph|streptococcus|cnst|vre"="gram positive",
              "klebs|coli|serrat|pseudo|steno|citro|acinet|enterobact"="gram negative")
bsi$org.short.4 <- recode2(bsi$org.short,recodes4,regexp=TRUE,else.value="Other Bacteria")
bsi$org.short.4

# if recodes are in list object, vectors of possible hits can be listed. This will do the same thing as #4.
recodes5 <- list("gram positive"=c("entero","staph","strep","cnst","vre"),
                 "gram negative"=c("klebs","coli","serrat","pseudo","steno","citro","acinet","enterobact"))
bsi$org.short.5 <- recode2(bsi$org.short,recodes5,regexp=TRUE,else.value="Other Bacteria")
bsi$org.short.5
}
\author{
Ying Taur
}
