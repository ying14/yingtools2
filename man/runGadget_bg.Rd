% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/yingtools2.R
\name{runGadget_bg}
\alias{runGadget_bg}
\title{Run a shiny gadget in background}
\usage{
runGadget_bg(app, args = list(), port = 4567)
}
\arguments{
\item{app}{A Shiny app object created by \code{\link[shiny:shinyApp]{shiny::shinyApp()}}}

\item{port}{The TCP port that the application should listen on.}
}
\value{
A \code{\link[callr:r_process]{callr::r_process}} object, which is running separately in the background.
}
\description{
Similar to \code{\link[shiny:runGadget]{shiny::runGadget()}}, you can use this to run shiny apps in the viewer pane of RStudio.
The difference is that the R console is not blocked during execution,
so you can continue coding while the shiny app is running.
}
\details{
This function works by deploying the Shiny app is run in the background
(using \code{\link[callr:r_bg]{callr::r_bg()}}), then having the viewer panel set to display the corresponding port.
If a process already exists that is listening to the port, that process is killed (using \code{\link[=kill_port_process]{kill_port_process()}}).
}
\examples{
library(shiny)
app <- shinyApp(ui = fluidPage(
  titlePanel(paste0("Hello Shiny!")),
  sidebarLayout(
    sidebarPanel(
      sliderInput(inputId = "bins",
                  label = "Number of bins:",
                  min = 1, max = 50, value = 30)
    ),
    mainPanel(
      plotOutput(outputId = "distPlot")
    )
  )
), server = function(input, output) {
  output$distPlot <- renderPlot({
    x    <- faithful$waiting
    bins <- seq(min(x), max(x), length.out = input$bins + 1)
    hist(x, breaks = bins, col = "#75AADB", border = "white",
         xlab = "Waiting time to next eruption (in mins)",
         main = "Histogram of waiting times")
  })
})
ps <- runGadget_bg(app)

# to stop the app, run this or quit RStudio
ps$kill()
}
